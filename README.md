**Построение модели распознавания жестов на основе данных ОМГ-датчиков**  
Выполнили:  
2 группа стажировки в компании "Моторика":Банзарханова Арюна, Новиков Павел, Хабиров Ильназ 

- **Постановка задачи**

Во всем мире растет количество людей с утраченными конечностями или их частью. Все эти люди нуждаются в реабилитации.  
Российская компания Моторика с помощью инновационных разработок помогает людям восстановить утраченые функции.  
Нам, команде студентов SkillFactory была предоставлена возможность поучаствовать в решении данных задач, в частности нам было предложено найти решение на основе машинного обучения задачи превращения данных с оптомиографических манжет в конкретный жест высокотехнологичного протеза.

Итак, есть пилот, на руке которого смонтирована манжета с датчиками, есть полученные данные и есть протез. Нужна модель машинного обучения которая свяжет все воедино и будет с приемлемлемой точностью предсказывать жесты по сигналам поступающим с датчиков.
Для этого нужно решить следующие задачи:

1. **Построить модель, которая на основе ОМГ-данных распознавала бы, какой жест выполняется в данный момент(задача многоклассовой классификации)**
2. **Скорость инференса решения должна быть меньше 33 мс на ПК;**
3. **Время донастройки манжеты нужно минимизировать, чтобы сократить период подготовки оборудования к использованию новым пилотом;**
4. **При разработке модели необходимо проверить, возможно ли обучить ее на данных предыдущих пилотов для последующего их использования новыми пилотами;**
5. **Решение должно быть потенциально портируемо на микроконтроллер.
Некоторые из этих задач были решены(модель, скорость, проверка модели на данных других пилотов**

**Знакомство с данными**

Данные представляют собой:

1. Данные, полученные от ОМГ-датчиков.
2. Протокол выполнения жестов, которому следовал пилот в ходе сбора данных

При первичном анализе данных были выявлены временные лаги между командами к выполнению жестов и началами изменений сигналов, поступающих с датчиков: т.е. могло иметь место простое запаздывание реакции пилота на команду, из-за чего мы и наблюдали некоторую рассинхронизизацию. Мы быстро согласились, что обучать модели предсказывать опережающий таргет по отстающим данным было бы не самым оптимальным решением, поэтому начали думать над способами устранения или минимизации сдвига между таргетом и данными с датчиков. 
И мы нашли удовлетворяющий нашим целям статистический метод. 

- **Предобработка данных**

Как было сказано ранее, преодбработку мы начали с **определения временной задержки и сдвига целевой переменной**. 
Мы думали над тем, как ухватить момент реакции на команду и совместить начало изменений в сигналах с таргетом.
Было создано два метода: использовался алгоритм машинного обучения из sklearn — ему подавалась вся матрица признаков, и в цикле высчитывалась точность предсказаний. Результаты каждой итерации сравнивались и находилось максимальное значение, соответствовавшее оптимальному сдвигу.
Другой же вариант, превзошедший первый по скорости, заключался в итеративном поиске максимальной корреляции целевой переменной и суммы модулей дифференцированных значений сигналов датчиков.
Любопытно, что оптимальные сдвиги, найденные обеими методами, могли немного не совпадать, но это может зависеть от выбора конкретного алгоритма МО в первом варианте и сравниваемой там метрики.

**Стандартизация**
 
Мы использовали вариант StandartScaler со стандартными отклонениями.

**Сглаживание данных**
Включение экспоненциального сглаживания позволяет уменьшить роль шумов и выбросов, помогая тем самым моделям лучше описывать моменты изменения жестов.
Мы сумели написать несколько функций, выполняющих эту задачу: были использованы оконные функции библиотеки scipy, функции из statsmodels, ну и, конечно, метод экспоненциального сглаживания из pandas.

Точность моделей на инференсе могла зависеть также от вариантов решений на этом этапе.

- **Генерация и отбор признаков**

Смысл этого этапа в том, чтобы выявить неявные закономерности в данных и нивелировать роль возможных выбросов и шумов с помощью новых признаковых описаний.

Мы проверили много разных методов, среди которых необходимо отметить:

**Генерацию признака суммы изменений значений за последние несколько временных шагов** — это еще один способ учитывать динамику изменений, который также позволяет избавиться от части шумов, а кроме того повышает корреляцию между изменениями признака и изменениями класса жестов в векторе целевой переменной, что может помочь модели ухватывать закономерности в данных при обучении.

Т.к. данные на графиках у нас имеют весьма сложный вид, чем-то напоминающий ансамбль кусочных функций:

показалось удачным решением попробовать воспользоваться различными типами затухания наиболее удаленных сигналов, но заметного положительного влияния на результаты зафиксировать пока что не удалось. 

Также использовался **метод включения признака временного лага** с шагом, который может позволить модели улавливать зависимости между значениями по времени. А вдруг это поможет алгоритму ухватить суть изменений и поймать момент переключения жеста. Однако использование лагов имеет и обратную сторону: т.к. данные представляют собой ряд повторяющихся серий жестов, слишком большое включение лаговых признаков может привести к тому, что модель выучит ритм, а не характерные для конкретных жестов закономерности в данных. И чтобы определить предельное, безопасное количество лагов, нужно предварительно изучить графики автокорреляции.
Максимальное количество лагов 46, это значит, что при обучение модели мы можем “смотреть назад” максимум на 46 временных отрезков

Следующие два способа основаны на методе построения пространства признаков с помощью задания параметрической регрессионной или аппроксимирующей модели временного ряда. В качестве новых признаков будут выступать параметры настроенной модели. В данном методе построения признакового описания возникает задача выбора аппроксимирующей модели.


Первый способ основан на использовании оптимальных параметров модели линейной регрессии. Была написана специальная оконная функция, которая проходит по всему массиву данных и высчитывает весовые коэффициенты для каждой строки с помощью МНК. Признаками для расчетов выступали точки времени. Таргетом в каждой итерации выступает строка из данных. Результатом на каждой итерации является вектор параметров.

Второй способ основан на использовании модели авторегрессии для каждого признака в данных. Специальная функция в двойном цикле проходит по столбцам массива данных и собирает матрицу коэффициентов.

Аналогично для генерации признаков можно также воспользоваться дискретным преобразованием Фурье. Еще можно снимать коэффициенты скрытого слоя автокодировщика. Оба из этих последних методов пока что остались не до конца реализованными, но перспективными.

**Feature selection**  

После генерации новых признаковых описаний наступает этап отбора. Здесь можно использовать метод корреляционного анализа, SelectKBest, метод рекурсивной элиминации признаков, а также методы понижения размерности.   

Корреляционный анализ можно рассматривать как способ упрощения массива данных для ускорения расчетов путем удаления высоко коррелированных признаков в приоритетном порядке.
Использование этого метода действительно помогло несколько улучшить результат. Но выбор порога отбора, процесс выбора конкретных признаков для удаления создает довольно богатое пространство поиска оптимальных вариантов, т.к. имеют значение комбинации удаляемых столбцов из таблицы, а результат мог измениться неочевидным образом.
Метод вполне может оправдать себя в нашей задаче, если уделять достаточно времени перебору предлагаемых им исходов.  

Хочется отметить PCA, так как он помогает решить проблему мультиколлинеарности путем отображения признаков в пространство меньшей размерности и выполняет ряд матричных преобразований, а не предлагает слепо удалять столбцы.

**Этап отбора модель-данные**  

Мы перебрали достаточно методов предобработки и генерации новых признаков, тем самым увеличив пространство возможных решений. Поле для поиска можно представить в виде двоичной таблицы — с единицами и нулями напротив использованных методов. Таким образом мы можем представить данные для подачи в модель во множестве разнообразных форм с разными комбинациями предобработки, генерации и отбора признаков.  
Тестировать эти данные целесообразно на множестве самых разных алгоритмов. Например, у нас есть пул из 20 алгоритмов с дефолтными настройками, которые мы отобрали для обучения.  
Всего видов данных для обучения может быть, например, 72. 
Тогда можно в двойном цикле обойти все эти данные, обучив на каждом сэмпле 20 моделей и собрать массив данных, составленный из метрик.   

Высокий результат Random Forest обеспечен при использовании комбинации исходных данных, коэффициентов авторегресси и линейной регрессии.  

Таким образом можно отыскать оптимальные пары модель-данные и приступить к инференсу. Есть вариант оптимизировать гиперпараметры. Также можно перенастроить методы предобработки, если соответствующие функции имели настраиваемые аргументы.



## Что сделано:   

**Построена модель, которая на основе ОМГ-данных распознавала бы, какой жест выполняется в данный момент(задача многоклассовой классификации)**
Найдено несколько решений, 3 вошли финальный репозиторий. Из них 2 на основе модели SVM и один на основе нейросети LTSM.  

**Скорость инференса решения меньше 33 мс на ПК;**  
 
Удалось уложится в установленный временной период работы 33 мс системы принятия решений.  
 
**При разработке модели проверено, возможно ли обучить ее на данных предыдущих пилотов для последующего их использования новыми пилотами**  

Была проверена возможность обучить модель на данных предыдущих пилотов, для последующего их использования новыми. 
Вывод: возможность есть, но результат нестабилен. Какие-то пилоты или их сочетание дают метрику больше 0.5 результат, но чаще всего нет.   

**Время донастройки манжеты нужно было минимизировать, чтобы сократить период подготовки оборудования к использованию новым пилотом;**
Данные исследования нами не проводились.

**Решение должно быть потенциально портируемо на микроконтроллер.**
Одно из наших решений прошло тест в офисе Моторики на виртуальном протезе, и показало свою работоспособность.

**Выводы**:   
Поиск решения проблемы с помощью машинного обучения это процесс, в котором важную роль играют все этапы от правильного сбора данных до постобработки получившегося в результате сигнала.

Осознана важность документирования результатов работы, т.к. по прошествии времени вспомнить порядок действий и их результат не представляется возможным.С другой стороны ведение протоколов  позволяет экономить время за счет переделывания одной и той же работы.  

Создание универсальной модели для каждого пилота требует дополнительных шагов по сегментации и одних только обобщенных данных недостаточно.  

Работа в реальных условиях действующего предприятия это не путь одних только открытий как во время учебы это зачастую хоть и интересная, но рутинная деятельность.  

В реальных условиях работоспособность решения определяется не только метрикой базовой модели, но и существующими техническими ограничениями, такими как объем памяти контроллера и скорость работы системы принятия решений  

Преимуществом командной работы является  объединение усилий людей с разными навыками и за счет этого удается создавать решения, которые в одиночку заняли бы гораздо больше времени. 

Во время работы над проектом “прокачался скилл” работы с Git, что при одиночной работе практически маловероятно.  

Кроме этого, появились практические навыки работы с нейронными сетями, c командным интепретатором Bash, а также с чатом GPT и приложением Notion
